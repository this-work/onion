import{w as L,i as S,t as m,n as T,a as w,b as O,c as V,d as W}from"./ClTvHOf_.js";import{a9 as g,aa as v,j as M,g as j,h as x,N as A,p as N}from"#entry";const I=S?window:void 0;function b(t){var o;const u=v(t);return(o=u?.$el)!=null?o:u}function k(...t){const o=[],u=()=>{o.forEach(e=>e()),o.length=0},d=(e,n,r,s)=>(e.addEventListener(n,r,s),()=>e.removeEventListener(n,r,s)),a=M(()=>{const e=m(v(t[0])).filter(n=>n!=null);return e.every(n=>typeof n!="string")?e:void 0}),p=V(()=>{var e,n;return[(n=(e=a.value)==null?void 0:e.map(r=>b(r)))!=null?n:[I].filter(r=>r!=null),m(v(a.value?t[1]:t[0])),m(N(a.value?t[2]:t[1])),v(a.value?t[3]:t[2])]},([e,n,r,s])=>{if(u(),!e?.length||!n?.length||!r?.length)return;const l=W(s)?{...s}:s;o.push(...e.flatMap(i=>n.flatMap(h=>r.map(f=>d(i,h,f,l)))))},{flush:"post"}),c=()=>{p(),u()};return O(u),c}function B(){const t=g(!1),o=A();return o&&x(()=>{t.value=!0},o),t}function D(t){const o=B();return M(()=>(o.value,!!t()))}function P(t,o,u={}){const{root:d,rootMargin:a="0px",threshold:p=0,window:c=I,immediate:e=!0}=u,n=D(()=>c&&"IntersectionObserver"in c),r=M(()=>{const f=v(t);return m(f).map(b).filter(T)});let s=w;const l=g(e),i=n.value?j(()=>[r.value,b(d),l.value],([f,C])=>{if(s(),!l.value||!f.length)return;const E=new IntersectionObserver(o,{root:b(C),rootMargin:a,threshold:p});f.forEach(y=>y&&E.observe(y)),s=()=>{E.disconnect(),s=w}},{immediate:e,flush:"post"}):w,h=()=>{s(),i(),l.value=!1};return O(h),{isSupported:n,isActive:l,pause(){s(),l.value=!1},resume(){l.value=!0},stop:h}}function q(t,o={}){const{window:u=I,scrollTarget:d,threshold:a=0,rootMargin:p,once:c=!1}=o,e=g(!1),{stop:n}=P(t,r=>{let s=e.value,l=0;for(const i of r)i.time>=l&&(l=i.time,s=i.isIntersecting);e.value=s,c&&L(e,()=>{n()})},{root:d,window:u,threshold:a,rootMargin:v(p)});return e}export{P as a,q as b,k as u};
